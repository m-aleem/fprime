#!/usr/bin/env python3
"""
# ===============================================================================
# NAME: generate_version_info.py
#
# DESCRIPTION:  Creates a version.hpp and version.json file with version informations
#
# USAGE: ./generate_version_info.py /path/to/outdir/
#
# AUTHOR: sfregoso
# EMAIL:  sfregoso@jpl.nasa.gov
# DATE CREATED  : Oct. 15, 2021
#
# Copyright 2021, California Institute of Technology.
# ALL RIGHTS RESERVED. U.S. Government Sponsorship acknowledged.
# ===============================================================================
"""
import argparse
import os
import sys
import json
from pathlib import Path
import subprocess


FALLBACK_VERSION = "v3.5.0"  # Keep up-to-date on release tag


def get_version_str(working_dir, fallback=FALLBACK_VERSION):
    """
    System call to get the version. It uses `git describe --tags --always --dirty --broken` to get a standard version string as used
    across fprime. The working directory should be set to a (project, library, fprime) from which to obtain the version.

    Args:
        working_dir: working directory to introspect for version
        fallback: version to fallback to if git is not working
    Return:
        String containing the version for the given working directory
    """
    try:
        output = subprocess.check_output(
            ["git", "describe", "--tags", "--always", "--dirty", "--broken"],
            cwd=working_dir,
        )
        return output.strip().decode("ascii")
    except Exception:
        return fallback


def get_fprime_version():
    """Calculate the fprime framework version

    Calculate the fprime framework version. This uses `get_version_str` and fallback to the FALLBACK_VERSION as
    specified within this file.

    Return:
        Version of fprime framework
    """
    fprime_directory = os.environ.get(
        "FPRIME_FRAMEWORK_PATH", os.path.dirname(__file__)
    )
    return get_version_str(working_dir=fprime_directory, fallback=FALLBACK_VERSION)


def get_project_version(fallback=FALLBACK_VERSION):
    """Calculate the fprime project version

    Calculate the fprime project version. This uses `get_version_str` and fallback to the FALLBACK_VERSION as
    specified within this file unless the fallback argument was passed in.

    Args:
        fallback: version to fallback to if git is not working

    Return:
        Version of fprime framework
    """
    fprime_directory = os.environ.get("FPRIME_PROJECT_ROOT", os.path.dirname(__file__))
    return get_version_str(working_dir=fprime_directory, fallback=fallback)


def get_library_versions(fallback=FALLBACK_VERSION) -> dict:
    """Calculate the versions of each libraries.
    Return a dictionary with the library name as key and the version as value
    """
    fprime_libraries = os.environ.get("FPRIME_LIBRARY_LOCATIONS", "")
    if fprime_libraries == "":
        return {}

    lib_versions = {}
    for library in fprime_libraries.split(":"):
        library_name = os.path.basename(library)
        lib_versions[library_name] = get_version_str(
            working_dir=library, fallback=fallback
        )
    return lib_versions


def create_version_file_hpp(output_dir, framework_version, project_version):
    """
    Create the version file using the provided name and path.
    """
    version_hpp = Path(output_dir) / "version.hpp.tmp"
    # Open file for writing
    with open(version_hpp, "w") as fid:
        fid.write("/*\n")
        fid.write(
            f"    This file has been autogenerated using [{os.path.basename(__file__)}].\n"
        )
        fid.write("    This file may be overwritten.\n")
        fid.write("*/\n")
        fid.write("#ifndef _VERSION_HPP_\n")
        fid.write("#define _VERSION_HPP_\n")
        fid.write("\n")
        fid.write('#include "Fw/FPrimeBasicTypes.hpp"\n')

        fid.write("namespace Project {\n\n")
        fid.write("struct Version {\n")
        fid.write(f"    static const char* const FRAMEWORK_VERSION;\n")
        fid.write(f"    static const char* const PROJECT_VERSION;\n")
        fid.write(f"    static const FwIndexType LIBRARY_VERSIONS_COUNT; \n")
        fid.write(f"    static const char* const LIBRARY_VERSIONS[];\n")
        fid.write("};\n\n")
        fid.write("}  // namespace Project\n")
        fid.write("#endif\n")


def create_version_file_cpp(output_dir, framework_version, project_version):
    """
    Create the version file using the provided name and path.
    """
    version_cpp = Path(output_dir) / "version.cpp.tmp"
    # Open file for writing
    with open(version_cpp, "w") as fid:
        fid.write("/*\n")
        fid.write(
            f"    This file has been autogenerated using [{os.path.basename(__file__)}].\n"
        )
        fid.write("    This file may be overwritten.\n")
        fid.write("*/\n")
        fid.write('#include "version.hpp"\n')
        fid.write("\n")

        fid.write("namespace Project {\n\n")
        fid.write(
            f'    const char* const Version::FRAMEWORK_VERSION = "{framework_version}";\n'
        )
        fid.write(
            f'    const char* const Version::PROJECT_VERSION = "{project_version}";\n'
        )
        lib_versions = get_library_versions()
        if len(lib_versions) == 0:
            fid.write(f"    const FwIndexType Version::LIBRARY_VERSIONS_COUNT = 0; \n")
            fid.write(f"    const char* const Version::LIBRARY_VERSIONS[] = {{ \n")
            fid.write("        nullptr\n")  # nullptr when no libraries are present
        else:
            fid.write(
                f"    const FwIndexType Version::LIBRARY_VERSIONS_COUNT = {len(lib_versions)}; \n"
            )
            fid.write(f"    const char* const Version::LIBRARY_VERSIONS[] = {{ \n")
            for lib_name, version in lib_versions.items():
                fid.write(f'        "{lib_name}@{version}",\n')
        fid.write("    };\n")
        fid.write("}  // namespace Project\n")


def create_version_file_json(
    output_dir: str, framework_version: str, project_version: str, lib_versions: dict
):
    """
    Create the version files using the provided name and path.
    """
    json_file = Path(output_dir) / "version.json.tmp"
    json_obj = {
        "framework_version": framework_version,
        "project_version": project_version,
        "library_versions": lib_versions,
    }
    with open(json_file, "w") as file:
        json.dump(json_obj, file)


def main():
    """
    Main program entry point
    """
    parser = argparse.ArgumentParser(description="Create version header")
    parser.add_argument(
        "output_dir",
        nargs="?",
        default=".",
        help="Path to write version header into",
    )
    parser.add_argument(
        "--check",
        action="store_true",
        default=False,
        help="Check framework and fallback version",
    )
    args = parser.parse_args()

    # Build the version output
    fprime_version = get_fprime_version()
    project_version = get_project_version()
    lib_versions = get_library_versions()
    create_version_file_hpp(args.output_dir, fprime_version, project_version)
    create_version_file_cpp(args.output_dir, fprime_version, project_version)
    create_version_file_json(
        args.output_dir, fprime_version, project_version, lib_versions
    )

    # Check version if asked to do so
    if args.check and not fprime_version.startswith(FALLBACK_VERSION):
        expected = fprime_version[: len(FALLBACK_VERSION)]
        print(
            f"[ERROR] Fallback version { FALLBACK_VERSION } not updated. Expected { expected }.",
            file=sys.stderr,
        )
        sys.exit(2)
    sys.exit(0)


if __name__ == "__main__":
    main()
